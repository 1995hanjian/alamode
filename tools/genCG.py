#!/usr/bin/env python
#
# genCG.py
#
# Simple script to generate CG files (xTAPP) for given displacement patterns
#
# Copyright (c) 2014 Terumasa Tadano
#
# This file is distributed under the terms of the MIT license.
# Please see the file 'LICENCE.txt' in the root directory 
# or http://opensource.org/licenses/mit-license.php for information.
#

"""
This python script generates CG files (input for xTAPP) of displaced configurations.
"""

import sys, os
import optparse
import numpy as np
from numpy.linalg import norm as norm2
from fractions import Fraction

usage = "usage: %prog [options] file.pattern_HARMONIC file.pattern_ANHARM3 ... \n \
      file.pattern_* can be generated by 'alm' with MODE = suggest."
parser = optparse.OptionParser(usage=usage)
parser.add_option('--mag', help="Magnitude of displacement in units of Angstrom (default: 0.02)")
parser.add_option('--prefix', help="Prefix of the files to be created (default: {basename of the given CG file}.{mag}_)")
parser.add_option('--cg', help="Original CG file with equilibrium atomic positions (default: None)")


def read_tappinput(file_in):

    list_tappinput = []
    flag_add = False

    with open(file_in) as openfileobject:
        for line in openfileobject:
            if "main" in line and "data" in line:
                flag_add = True
                list_tappinput.append(line)
            elif "#" in line:
                flag_add = False
            elif flag_add:
                list_tappinput.append(line)

    if len(list_tappinput) == 0:
        print "main data entry not found"
        exit(1)

    list_tappinput_new = []

    for obj in list_tappinput:
        obj_split = obj.rstrip().split(',')
        for subobj in obj_split:
            if subobj:
                list_tappinput_new.append(subobj)

    str_input = ""

    for entry in list_tappinput_new:
        str_input += entry + " "

    entrylist = str_input.split()
    lavec_list = []

    a = 0.0
    nkd = 0
    nat = 0

    # get lattice_factor
    for i in range(len(entrylist)):
        if "lattice_factor" in entrylist[i]:
            a = float(entrylist[i+2])

        if "lattice_list" in entrylist[i]:
            for j in range(9):
                lavec_list.append(entrylist[i+j+2])

        if "number_element" in entrylist[i]:
            nkd = int(entrylist[i+2])

        if "number_atom" in entrylist[i]:
            nat = int(entrylist[i+2])
    
    if a == 0.0:
        print "Couldn't read lattice_factor"
        exit(1)
    if nkd == 0:
        print "Couldn't read number_element"
        exit(1)
    if nat == 0:
        print "Couldn't read number_atom"
        exit(1)
    if len(lavec_list) != 9:
        print "Couldn't read lattice_list"
        exit(1)

    lavec = np.zeros((3,3))

    Bohr_to_angstrom = 0.5291772108
    a *= Bohr_to_angstrom

    for i in range(3):
        for j in range(3):
            lavec[j][i] = a * float(lavec_list[3 * i + j])

    return lavec, nat, nkd, list_tappinput


def read_kpdata(file_in):

    list_kpoint = []
    flag_add = False

    with open(file_in) as openfileobject:
        for line in openfileobject:
            if "k-points" in line.rstrip():
                flag_add = True
                list_kpoint.append(line)
            elif "#" in line.strip():
                flag_add = False
            elif flag_add:
                list_kpoint.append(line)

    if len(list_kpoint) == 0:
        print "k-points data entry not found"
        exit(1)

    return list_kpoint


def read_structure_optimize(file_in):

    list_opt = []
    flag_add = False

    with open(file_in) as openfileobject:
        for line in openfileobject:
            if "struct_opt" in line.rstrip():
                flag_add = True
                list_opt.append(line)
            elif "#" in line.strip():
                flag_add = False
            elif flag_add:
                list_opt.append(line)

    if len(list_opt) == 0:
        print "struct_opt entry not found"
        exit(1)

    list_opt2 = []
    flag_add = False

    with open(file_in) as openfileobject:
        for line in openfileobject:
            if "str_opt_constr" in line.rstrip():
                flag_add = True
                list_opt2.append(line)
            elif "#" in line.strip():
                flag_add = False
            elif flag_add:
                list_opt2.append(line)

    if len(list_opt2) == 0:
        print "str_opt_constr entry not found"
        exit(1)

    return list_opt, list_opt2


def read_atomdata(file_in, nat_in, nkd_in):
    
    list_atom = []
    flag_add = False

    with open(file_in) as openfileobject:
        for line in openfileobject:
            if "atom" in line and "data" in line:
                flag_add = True
                list_atom.append(line)
            elif "#" in line.strip():
                flag_add = False
            elif flag_add:
                list_atom.append(line)

    if len(list_atom) == 0:
        print "atom data entry not found"
        exit(1)

    x_out = np.zeros((nat_in, 3), dtype=float)
    kd_out = np.zeros(nat_in, dtype=int)

    for i in range(nat_in):
        list_tmp = list_atom[i + nkd_in + 1].rstrip().split()
        kd_out[i] = int(list_tmp[0])
        for j in range(3):
            x_out[i][j] = float(list_tmp[j+1])

    return x_out, kd_out, list_atom

    
def read_CG(file_in):
    
    lavec, nat, nkd, str_tappinput = read_tappinput(file_in)
    str_kpoint = read_kpdata(file_in)
    str_struct_opt, str_opt_constr = read_structure_optimize(file_in)
    x, kd, str_atom = read_atomdata(file_in, nat, nkd)

    str_header = ""

    for entry in str_tappinput:
        str_header += entry
    for entry in str_kpoint:
        str_header += entry
    for entry in str_struct_opt:
        str_header += entry
    for entry in str_opt_constr:
        str_header += entry
    for i in range(nkd+1):
        str_header += str_atom[i]

    lavec = np.matrix(lavec)
    lavec_inv = np.array(lavec.I)

    return str_header, nat, nkd, lavec, lavec_inv, x, kd


def parse_displacement_patterns(files_in):

	pattern = []

	for file in files_in:
		pattern_tmp = []

		f = open(file, 'r')

		tmp, basis = f.readline().rstrip().split(':')

		if basis == 'F':
			print "Warning: DBASIS must be 'C'"
			exit(1)
		
		while True:
			line = f.readline()

			if not line:
				break

			line_split_by_colon = line.rstrip().split(':')
			is_entry = len(line_split_by_colon) == 2

			if is_entry:
				pattern_set = []
				natom_move = int(line_split_by_colon[1])
				for i in range(natom_move):
					disp = []
					line = f.readline()
					line_split = line.rstrip().split() 
					disp.append(int(line_split[0]))
					for j in range(3):
						disp.append(float(line_split[j + 1]))

					pattern_set.append(disp)
				pattern_tmp.append(pattern_set)


		print "File %s containts %i displacement patterns" % (file, len(pattern_tmp))


		for entry in pattern_tmp:
			if not entry in pattern:
				pattern.append(entry)

		f.close()

        print
	print "Number of unique displacement patterns = ", len(pattern)

	return pattern

def char_xyz(entry):
	if entry % 3 == 0:
		return 'x'
	elif entry % 3 == 1:
		return 'y'
	elif entry % 3 == 2:
		return 'z'

def gen_displacement(counter_in, pattern, disp_mag, nat, invlavec):

    
    poscar_header = "Disp. Num. %i" % counter_in
    poscar_header += " ( %f Angstrom" % disp_mag

    disp = np.zeros((nat, 3))

    for displace in pattern:
        atom = displace[0] - 1

        poscar_header += ", %i : " % displace[0]

        str_direction = ""

        for i in range(3):
            if abs(displace[i + 1]) > 1.0e-10:
                if displace[i + 1] > 0.0:
                    str_direction += "+" + char_xyz(i)
                else:
                    str_direction += "-" + char_xyz(i)

            disp[atom][i] += displace[i + 1] * disp_mag

        poscar_header += str_direction


    poscar_header += ")"

    for i in range(nat):
        disp[i] = np.dot(disp[i], invlavec.T)

    return poscar_header, disp


def gen_CG(prefix, suffix, counter, nzerofills, str_header, nat, kd, x, u, nsym, symop, denom_tran, has_inv):
    
    filename = prefix + str(counter).zfill(nzerofills) + "." + suffix
    f = open(filename, 'w')
    f.write("%s" % str_header)

    for i in range(nat):
        f.write("%i %20.15f %20.15f %20.15f\n" % (kd[i], x[i][0] + u[i,0], x[i][1] + u[i,1], x[i][2] + u[i,2]))

    f.write("# symmetry data\n")
    f.write("&symmetry\n")
    f.write("  number_sym_op = %i\n" % nsym)
    f.write("  has_inversion = %i\n" % has_inv)
    f.write("  denom_trans = %i\n" % denom_tran)
    f.write("/\n")


    mat_tmp = np.zeros((3,3), dtype=int)

    for elems in symop:
        for i in range(3):
            for j in range(3):
                mat_tmp[i][j] = elems[3 * i + j]

        mat_inv = np.matrix(mat_tmp).I

        for i in range(3):
            for j in range(3):
                f.write("%4i" % mat_inv[i,j])

        f.write("   ")
        for i in range(3):
            f.write("%4i" % elems[9+i])

        f.write("\n")
                

    f.write("\n")
    f.close()

def get_number_of_zerofill(npattern):

	nzero = 1

	while True:
		npattern /= 10

		if npattern == 0:
			break

		nzero += 1

	return nzero


if __name__ == '__main__':
    
	options, args = parser.parse_args()
	file_pattern = args[0:]

	if len(file_pattern) == 0:
		print "Usage: genCG.py [options] file1.pattern_HARMONIC file2.pattern_ANHARM3 ..."
		print "file.pattern_* can be generated by 'alm' with MODE = suggest."
		print 
		print "For details of available options, please type\n$ python genCG.py -h"
		exit(1)

        if options.cg == None:
            print "Error : --cg option not given"
            exit(1)
        else:
            prefix_default, suffix = options.cg.split('.')
            cg_orig = options.cg

            
	if options.prefix == None:
		print "--prefix option not given"
		print "Output format of %s.{mag}_{number}.%s will be used.\n" % (prefix_default, suffix)
		prefix = prefix_default + "." + options.mag + "_"

	else:
		print "Prefix of the output files : ", options.prefix
		print "Output format of %s{number}.%s will be used.\n" % (options.prefix, suffix)
		prefix = options.prefix
       
	if options.mag == None:
		disp_length = 0.02
		print "--magnitude option not given."
                print "Substituted by the default value (0.02)\n"

	else:
		disp_length = float(options.mag)
	
	print "Atomic displacement of %f angstrom will be used." % disp_length
	print "Original atomic positions will be read from the file %s." % cg_orig
	print

        str_header, nat, nkd, aa, aa_inv, x_frac, kd = read_CG(cg_orig)

	print "Equilibrium atomic positions were successfully read from the file %s" % cg_orig
	print "Number of atoms : ", nat
        print

	disp_pattern = parse_displacement_patterns(args[:])
	nzerofills = get_number_of_zerofill(len(disp_pattern))
	counter = 0

	for pattern in disp_pattern:
            counter += 1
            header, disp = gen_displacement(counter, pattern, disp_length, nat, aa_inv)

            nsym = 1
            symop = []
            symop.append([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0])
            denom_tran = 1
            has_inv = 0
                
            gen_CG(prefix, suffix, counter, nzerofills, str_header, nat, kd, x_frac, disp, nsym, symop, denom_tran, has_inv)

        print
	print "All CG files are created."

		

	





